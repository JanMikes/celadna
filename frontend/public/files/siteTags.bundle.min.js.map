{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./modules/stateCache.ts","webpack:///./utils/logger.ts","webpack:///./utils/callbackUtils.ts","webpack:///./modules/events.ts","webpack:///./consts/consts.ts","webpack:///./utils/tryParse.ts","webpack:///./utils/xhr.ts","webpack:///./types.ts","webpack:///./dom-manipulation/nodeBuilder.ts","webpack:///./dom-manipulation/domContentParser.ts","webpack:///./modules/siteEmbedder.ts","webpack:///./utils/experiments.ts","webpack:///./modules/tags.ts","webpack:///./API/siteApi.ts","webpack:///./utils/wixEmbedsAPIClient.ts","webpack:///./utils/extractQueryParameter.ts","webpack:///./API/siteApiHandlers.ts","webpack:///./integration/viewer.ts","webpack:///./siteTagsAPI.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","loadingTags","loadedTags","errorTags","embedTags","categories","config","addTagEmbeds","tagsToAdd","forEach","tag","push","embeddedNodes","getSiteEmbedTags","setConfig","conf","Array","isArray","getConfig","dumbClone","updateConsentCategories","policy","calculateNewCategories","keys","filter","indexOf","setLoading","_loadingTags","removeLoadingTag","tagName","getLoadingTags","addLoadedTag","_loadedTag","getLoadedTags","addLoadErrorTag","_loadErrorTag","getLoadErrorTags","obj","JSON","stringify","showLogs","debugLogs","_window","window","debug","location","search","toLowerCase","e","logDecision","error","text","console","PREFiX","log","runCallback","callback","data","async","callbackOp","setTimeout","createTagCallBack","eventName","embed","storageMethod","isIE","document","documentMode","publishEvent","publishingNode","eventData","customEvent","createEvent","initCustomEvent","CustomEvent","detail","dispatchEvent","eventNames","TAG_MANAGER_LOADED","TAGS_LOADING","TAG_LOADED","TAG_LOAD_ERROR","BASE_URL","SITES_API","HOSTS_API","WIX_DOMAINS","HOST_NAMES","EDITOR","EDITOR_X","ADI","APP_BUILDER","BUSINESS_MANAGER","BUSINESS_MANAGER_EDITOR_X","SITES_LIST","VIEWER","LOGO_BUILDER","ART_STORE","TEMPLATES","FUNNEL","DEV_CENTER","ARENA","LOGIN_PAGE","LOGIN_PAGE_EDITOR_X","PREMIUM","PREMIUM_TAGS","PREMIUM_EDITOR_X_TAGS","SUPPORT","ACCOUNT_MANAGER","APP_MARKET_STANDALONE","COMPONENT_STUDIO","PREMIUM_DOMAINS_WHOIS","PREMIUM_DOMAINS","RELEASE_NOTES","PREMIUM_MP_CONTAINER","GET_FEEDBACK","MOBILE_WEB_DASHBOARD","METASITE_APP_DEF_ID","SHOULD_RENDER_TAGS_PER_PAGE_SPEC","tryParse","str","res","parse","message","xhrGeneric","uri","successCallback","errorCallback","options","headers","query","xhr","XMLHttpRequest","method","postBody","url","buildQuery","open","onreadystatechange","readyState","status","responseText","setRequestHeader","send","queryString","queryParam","encodeURIComponent","substr","length","Position","buildNode","nodeInfo","callbacks","node","nodeType","Node","TEXT_NODE","createTextNode","content","COMMENT_NODE","createComment","createElement","attributes","NamedNodeMap","attr","setAttribute","script","src","blob","Blob","type","URL","createObjectURL","createUrlBlob","addEventListener","onload","onerror","enhanceScript","children","childNode","renderedChild","appendChild","parseEmbedData","toRender","div","innerHTML","childNodes","nodeData","extractNodeData","domContent","textContent","nodeValue","hasChildNodes","nodeName","applySiteEmbeds","tags","pageInfo","experiments","tagsWithoutEmbeddedNodes","tagsToEmbed","spec","isExperimentOpen","id","pages","includes","shouldRenderOnPage","isTagValidForPage","filterTagsByPageID","map","siteEmbed","nodesToEmbed","embedLocation","position","HEAD","body","head","renderingInput","parentNode","before","resultNodes","counters","firstChild","resultNode","insertBefore","createSiteEmbed","BODY_START","buildTagApiUrl","baseUrl","metasiteId","wixSite","isWixDomain","domain","hostname","isWixSite","getSiteTags","params","htmlsiteId","language","consentPolicyManager","_getConsentPolicyHeader","wixEmbedsAPI","getCurrentPageInfo","omit","parameterName","source","queryParamData","split","decodeURIComponent","undefined","extractQueryParameter","getAppToken","authorization","response","siteEmbedsHandlerOptions","embedsData","currentPageID","initConsentPolicyManager","errors","consentPolicy","init","siteEmbedsHandler","err","onPageNavigation","loadOnce","removeChild","onConsentPolicyChanged","event","getExternalBaseUrl","getHtmlSiteId","getMetaSiteId","getLanguage","api","initTagManager","registerToEvent","wixTagManager"],"mappings":"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","file":"siteTags.bundle.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://static.parastorage.com/services/tag-manager-client/1.427.0/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","import { tryParse } from '../utils/tryParse';\nimport { SiteTag, SiteEmbededTag, Category } from '../types';\n\nlet loadingTags: any[] = [];\nconst loadedTags: any[] = [];\nconst errorTags: any[] = [];\nconst embedTags: SiteEmbededTag[] = [];\nlet categories: Category[] = [];\nlet config = {};\n\nexport function addTagEmbeds(tagsToAdd: SiteTag[]) {\n  tagsToAdd.forEach((tag) => {\n    embedTags.push({\n      tag,\n      embeddedNodes: null,\n    });\n  });\n}\n\nexport function getSiteEmbedTags(): SiteEmbededTag[] {\n  // Return the reference since it has DOM references\n  return embedTags;\n}\n\nexport function setConfig(conf: any) {\n  if (typeof conf === 'object' && !Array.isArray(conf)) {\n    config = { ...config, ...conf };\n  }\n}\n\nexport function getConfig() {\n  return dumbClone(config);\n}\n\nexport function updateConsentCategories(policy: { [key: string]: boolean }) {\n  if (policy && typeof policy === 'object') {\n    categories = [...categories, ...calculateNewCategories(policy)];\n  }\n}\n\nexport function calculateNewCategories(policy: { [key: string]: boolean }) {\n  return (Object.keys(policy) as Category[]).filter(\n    (key) => !!policy[key] && categories.indexOf(key) === -1,\n  );\n}\n\nexport function getConsentCategories(): Category[] {\n  return categories;\n}\n\nexport function setLoading(_loadingTags: any[]) {\n  loadingTags = _loadingTags;\n}\n\nexport function removeLoadingTag(tagName: string) {\n  loadingTags = loadingTags.filter((tag) => tag.name !== tagName);\n}\n\nexport function getLoadingTags() {\n  return dumbClone(loadingTags);\n}\n\nexport function addLoadedTag(_loadedTag: any) {\n  loadedTags.push(_loadedTag);\n}\n\nexport function getLoadedTags() {\n  return dumbClone(loadedTags);\n}\n\nexport function addLoadErrorTag(_loadErrorTag: any) {\n  errorTags.push(_loadErrorTag);\n}\n\nexport function getLoadErrorTags() {\n  return dumbClone(errorTags);\n}\n\nfunction dumbClone(obj: any) {\n  return tryParse(JSON.stringify(obj));\n}\n","const PREFiX = 'Tag Manager: ';\nconst showLogs = logDecision();\n\nfunction logDecision() {\n  let debugLogs = false;\n  try {\n    const _window = window as any;\n    debugLogs =\n      (_window && _window.debug) ||\n      (_window.location &&\n        (_window.location.search || '').toLowerCase().indexOf('debug=') > -1);\n  } catch (e) {\n    // Linty linter linted something\n  }\n  return debugLogs;\n}\n\nfunction error(text: string) {\n  showLogs && console && console.error(`${PREFiX} ${text}`);\n}\n\nfunction log(text: string) {\n  showLogs && console && console.log(`${PREFiX} ${text}`);\n}\n\nexport { log, error };\n","import { publishEvent } from '../modules/events';\nimport { removeLoadingTag } from '../modules/stateCache';\nimport { error } from './logger';\n\nfunction runCallback(callback: Function | any, data?: any, async?: boolean) {\n  const callbackOp = () => {\n    try {\n      if (typeof callback === 'function') {\n        return callback(data);\n      }\n    } catch (e) {\n      error(e);\n    }\n  };\n  return async === true ? setTimeout(callbackOp, 0) : callbackOp();\n}\n\n/**\n * Creates a function callback to handle loading of a full tag\n * @param eventName\n * @param tagName\n * @param embed\n * @param storageMethod\n */\nfunction createTagCallBack(\n  eventName: string,\n  tagName: string | any,\n  embed: any,\n  storageMethod: Function,\n) {\n  return () => {\n    publishEvent(eventName, window as any, {\n      tagName,\n      embed,\n    });\n    storageMethod(embed);\n    removeLoadingTag(embed.name);\n  };\n}\n\nexport { runCallback, createTagCallBack };\n","// @ts-ignore\nconst isIE = !!document.documentMode;\n/**\n * Publishes a custom event when there is CPU time\n * @param eventName - the name of the custom event\n * @param publishingNode - on which Dom node to dispatch it (window / document ...)\n * @param eventData - the detail of the event, will be available under detail\n */\nfunction publishEvent(eventName: string, publishingNode: Node, eventData: any) {\n  let customEvent: any;\n  if (isIE) {\n    customEvent = document.createEvent('CustomEvent');\n    customEvent.initCustomEvent(eventName, true, true, eventData);\n  } else {\n    customEvent = new CustomEvent(eventName, { detail: eventData });\n  }\n  if (publishingNode && publishingNode.dispatchEvent) {\n    setTimeout(() => {\n      // Don't want to disrupt the standard loading flow\n      // @ts-ignore\n      publishingNode.dispatchEvent(customEvent);\n    }, 0);\n  }\n}\n\nexport const eventNames = {\n  TAG_MANAGER_LOADED: 'TagManagerLoaded',\n  TAGS_LOADING: 'LoadingTags',\n  TAG_LOADED: 'TagLoaded',\n  TAG_LOAD_ERROR: 'TagLoadError',\n};\n\nexport { publishEvent };\n","const BASE_URL = '_api/tag-manager/api/v1/tags/';\nexport const SITES_API = `${BASE_URL}sites/`;\nexport const HOSTS_API = `/${BASE_URL}hosts/`;\nexport const WIX_DOMAINS = ['.wix.com', '.editorx.com'];\nexport const HOST_NAMES = {\n  EDITOR: 'EDITOR',\n  EDITOR_X: 'EDITOR_X',\n  ADI: 'ADI',\n  APP_BUILDER: 'APP_BUILDER',\n  BUSINESS_MANAGER: 'BUSINESS_MANAGER',\n  BUSINESS_MANAGER_EDITOR_X: 'BUSINESS_MANAGER_EDITOR_X',\n  SITES_LIST: 'SITES_LIST',\n  VIEWER: 'VIEWER',\n  LOGO_BUILDER: 'LOGO_BUILDER',\n  ART_STORE: 'ART_STORE',\n  TEMPLATES: 'TEMPLATES',\n  FUNNEL: 'FUNNEL',\n  DEV_CENTER: 'DEV_CENTER',\n  ARENA: 'ARENA',\n  LOGIN_PAGE: 'LOGIN_PAGE',\n  LOGIN_PAGE_EDITOR_X: 'LOGIN_PAGE_EDITOR_X',\n  PREMIUM: 'PREMIUM',\n  PREMIUM_TAGS: 'PREMIUM_TAGS',\n  PREMIUM_EDITOR_X_TAGS: 'PREMIUM_EDITOR_X_TAGS',\n  SUPPORT: 'SUPPORT',\n  ACCOUNT_MANAGER: 'ACCOUNT_MANAGER',\n  APP_MARKET_STANDALONE: 'APP_MARKET_STANDALONE',\n  COMPONENT_STUDIO: 'COMPONENT_STUDIO',\n  PREMIUM_DOMAINS_WHOIS: 'PREMIUM_DOMAINS_WHOIS',\n  PREMIUM_DOMAINS: 'PREMIUM_DOMAINS',\n  RELEASE_NOTES: 'RELEASE_NOTES',\n  PREMIUM_MP_CONTAINER: 'PREMIUM_MP_CONTAINER',\n  GET_FEEDBACK: 'GET_FEEDBACK',\n  MOBILE_WEB_DASHBOARD: 'MOBILE_WEB_DASHBOARD',\n};\nexport const METASITE_APP_DEF_ID = '22bef345-3c5b-4c18-b782-74d4085112ff';\nexport const SHOULD_RENDER_TAGS_PER_PAGE_SPEC = 'specs.tagManagerRenderTagByPageID';\n","import { error } from './logger';\n\nexport function tryParse(str: string) {\n  let res: any = str;\n  try {\n    res = JSON.parse(str);\n  } catch (e) {\n    error('Parse error in string');\n    error(e.message);\n  }\n  return res;\n}\n","import { runCallback } from './callbackUtils';\n\nfunction xhrGeneric(\n  uri: string,\n  successCallback: Function,\n  errorCallback: Function,\n  options: {\n    query?: any;\n    postBody?: string;\n    headers?: any;\n  },\n) {\n  const headers = (options && options.headers) || {};\n  const query = (options && options.query) || {};\n  headers['content-type'] = headers['content-type'] || 'application/json';\n  const xhr = new XMLHttpRequest();\n  const method = options && options.postBody ? 'POST' : 'GET';\n  const url = `${uri}${buildQuery(query)}`;\n  xhr.open(method, url, true);\n  xhr.onreadystatechange = () => {\n    if (xhr.readyState === 4) {\n      const status = xhr.status;\n      if (status < 200 || status >= 300) {\n        runCallback(errorCallback, { status, responseText: xhr.responseText });\n      } else {\n        runCallback(successCallback, xhr.responseText);\n      }\n    }\n  };\n  Object.keys(headers).forEach((key: string) => {\n    if (headers[key] !== void 0) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n  });\n  xhr.send((options && options.postBody) || null);\n}\n\nfunction buildQuery(query: any) {\n  let queryString = '';\n  if (typeof query === 'object') {\n    Object.keys(query).forEach((queryParam: string) => {\n      if (query[queryParam] !== void 0) {\n        const value = encodeURIComponent(query[queryParam]);\n        queryString += `${encodeURIComponent(queryParam)}=${value}&`;\n      }\n    });\n  }\n  // Remove trailing &\n  queryString = queryString\n    ? queryString.substr(0, queryString.length - 1)\n    : '';\n  // Append ?\n  return queryString ? `?${queryString}` : '';\n}\n\nexport { xhrGeneric, buildQuery };\n","export type Category =\n  | 'essential'\n  | 'functional'\n  | 'analytics'\n  | 'advertising'\n  | 'dataToThirdParty';\n\nexport interface Tag {\n  // The id of the tag - doesn't always exist\n  id?: string;\n  // The name of the tag - always exists\n  name?: string;\n  // The data to be injected to the template\n  config?: Object;\n  // The category this tag belongs to\n  category?: Category;\n  // A source url for the script tag\n  sourceUrl: string;\n}\n\nexport enum Position {\n  HEAD = 'head',\n  BODY_START = 'bodyStart',\n  BODY_END = 'bodyEnd',\n}\n\nexport interface SiteTag {\n  // The id of the tag from the service\n  id?: string | null;\n  // The human readable name of the tag\n  name?: string | null;\n  // The HTML content ready for embedding in the site\n  content?: string | null;\n  // The configuration which was merged with the HTML content in the server\n  config?: { [key: string]: any } | null;\n  // Where this tag should be located\n  position?: Position | null;\n  // Indicator if tag should be re-evaluated on page navigation\n  loadOnce?: boolean | null;\n  // Expected domain to run this tag\n  domain?: string | null;\n  // The Consent Category of this tag\n  category?: Category;\n  //A list of page ids this tag should be embedded in, empty for embedding on all pages\n  pages?: string[] | null;\n}\n\nexport interface SiteTagsResponse {\n  // The tags we will add to the DOM\n  tags: SiteTag[];\n  // The configuration output from the tag manager\n  config?: any;\n  // Any errors we encountered in the service\n  errors?: any;\n}\n\nexport interface HostTagsResponse {\n  // The tags we will add to the DOM\n  tags: Tag[];\n  // The configuration output from the tag manager\n  config?: any;\n  // Any errors we encountered in the service\n  errors?: any;\n}\n\nexport interface SiteEmbededTag {\n  // The SiteTag definition of this embed\n  tag: SiteTag;\n  // DOM nodes reference to nodes we've added to the document\n  embeddedNodes: any;\n}\n\nexport interface getSiteTagParams {\n  // The base URL of the site\n  baseUrl: string;\n  // The metaSite we are currently on\n  metasiteId: string;\n  // The HTML site we are currently on\n  htmlsiteId: string;\n  // The two letter language code for the site we are currently on\n  language: string;\n  // If this is a wix.com / editorx.com site\n  wixSite?: boolean;\n  // will only bring the tags in these categories.\n  categories?: Category[];\n}\n\nexport interface NodeToRender {\n  nodeType?: number;\n  attributes?: NamedNodeMap | any;\n  content: string;\n  tag: string;\n  children?: NodeToRender[];\n}\n\nexport interface PageInfo {\n  id?: string;\n  type?: string;\n}\n\nexport interface SiteEmbedsHandlerOptions {\n  initConsentPolicyManager: boolean;\n  currentPageID: string | undefined;\n}\n","import { runCallback } from '../utils/callbackUtils';\nimport { NodeToRender } from '../types';\n\nfunction buildNode(\n  nodeInfo: NodeToRender,\n  callbacks: {\n    onload?: Function;\n    onerror?: Function;\n  },\n) {\n  let node: HTMLElement | Node;\n  if (nodeInfo.nodeType === Node.TEXT_NODE) {\n    node = document.createTextNode(nodeInfo.content);\n  } else if (nodeInfo.nodeType === Node.COMMENT_NODE) {\n    node = document.createComment(nodeInfo.content);\n  } else {\n    node = document.createElement(nodeInfo.tag);\n    if (nodeInfo && nodeInfo.attributes instanceof NamedNodeMap) {\n      Array.prototype.forEach.call(nodeInfo.attributes, (attr: any) => {\n        setAttribute(node, attr.name, attr.value);\n      });\n    } else if (typeof nodeInfo.attributes === 'object') {\n      Object.keys(nodeInfo.attributes).forEach((key: string) => {\n        if (typeof nodeInfo.attributes[key] !== void 0) {\n          setAttribute(node, key, nodeInfo.attributes[key]);\n        }\n      });\n    }\n\n    if (nodeInfo.tag === 'SCRIPT') {\n      enhanceScript(node, nodeInfo.content, callbacks);\n    } else if (nodeInfo.children && nodeInfo.children.length > 0) {\n      nodeInfo.children.forEach((childNode) => {\n        const renderedChild = buildNode(childNode, callbacks);\n        node.appendChild(renderedChild);\n      });\n    }\n  }\n  return node;\n}\n\nfunction enhanceScript(\n  script: HTMLScriptElement | any,\n  content: string = '',\n  callbacks: {\n    onload?: Function;\n    onerror?: Function;\n  },\n) {\n  if (content) {\n    script.src = createUrlBlob(content);\n  }\n  script.addEventListener(\n    'load',\n    () => {\n      runCallback(callbacks && callbacks.onload, null);\n    },\n    false,\n  );\n  script.addEventListener(\n    'error',\n    () => {\n      runCallback(callbacks && callbacks.onerror, null);\n    },\n    false,\n  );\n}\n\nfunction setAttribute(\n  node: HTMLElement | HTMLScriptElement | any,\n  key: string,\n  value: any,\n) {\n  node.setAttribute(key, value);\n}\n\nfunction createUrlBlob(content: string) {\n  const blob = new Blob([content], {\n    type: 'text/javascript;charset=utf-8',\n  });\n  return URL.createObjectURL(blob);\n}\n\nexport { buildNode };\n","import { NodeToRender } from '../types';\n\n/**\n * Parses the embed content to be able to attach it to the DOM and make it run\n * @param content\n */\nfunction parseEmbedData(content: string | any): NodeToRender[] {\n  const toRender: NodeToRender[] = [];\n  const div = document.createElement('DIV');\n  div.innerHTML = content;\n  Array.prototype.forEach.call(div.childNodes, (node) => {\n    const nodeData = extractNodeData(node);\n    toRender.push(nodeData);\n  });\n  return toRender;\n}\n\nfunction extractNodeData(node: HTMLElement | any): NodeToRender {\n  const nodeType = node.nodeType;\n  const domContent = node.innerHTML || node.textContent || node.nodeValue;\n  const children: NodeToRender[] = [];\n\n  if (node.hasChildNodes()) {\n    Array.prototype.forEach.call(node.childNodes, (childNode) => {\n      children.push(extractNodeData(childNode));\n    });\n  }\n  return {\n    nodeType,\n    tag: node.nodeName,\n    attributes: node.attributes,\n    content: domContent,\n    children,\n  };\n}\n\nexport { parseEmbedData };\n","import {eventNames, publishEvent} from './events';\nimport {createTagCallBack, runCallback} from '../utils/callbackUtils';\nimport {buildNode} from '../dom-manipulation/nodeBuilder';\nimport {parseEmbedData} from '../dom-manipulation/domContentParser';\nimport {NodeToRender, Position, SiteEmbededTag, PageInfo, SiteTag} from '../types';\nimport {addLoadedTag, addLoadErrorTag, setLoading,} from './stateCache';\nimport {filterTagsByPageID, getSiteTagsFromSiteEmbed} from './tags'\nimport {SHOULD_RENDER_TAGS_PER_PAGE_SPEC} from \"../consts/consts\";\nimport {isExperimentOpen} from \"../utils/experiments\";\n\n/**\n *  Iterate through the embeds collection and apply them to the DOM\n *  Keep a reference to any nodes that need to be reapplied for removal\n *  Keep a reference to any embeds that should be reapplied to re-apply them\n * @param tags - tags list from tag-manager-server.\n * @param pageInfo - represent that page information to load the tags list on .\n * @param experiments - map of experiments for A/B testing and gradually releases.\n */\nfunction applySiteEmbeds(tags: SiteEmbededTag[], pageInfo: PageInfo, experiments: Record<string, string>) {\n\n  const tagsWithoutEmbeddedNodes: SiteEmbededTag[] = tags.filter(tag => !tag.embeddedNodes);\n  const shouldRenderTagsPerPage: boolean = isExperimentOpen(experiments, SHOULD_RENDER_TAGS_PER_PAGE_SPEC);\n  const tagsToEmbed: SiteEmbededTag[] = shouldRenderTagsPerPage ? filterTagsByPageID(tagsWithoutEmbeddedNodes, pageInfo) : tagsWithoutEmbeddedNodes;\n\n  const loadingTags: SiteTag[] = getSiteTagsFromSiteEmbed(tagsToEmbed);\n  setLoading(loadingTags);\n  publishEvent(eventNames.TAGS_LOADING, window as any, loadingTags);\n\n  tagsToEmbed.forEach((siteEmbed: SiteEmbededTag) => {\n    const tag = siteEmbed.tag;\n    const nodesToEmbed = parseEmbedData(tag.content);\n    const embedLocation =\n      tag.position && tag.position !== Position.HEAD\n        ? document.body\n        : document.head;\n\n    const embeddedNodes = createSiteEmbed(\n      nodesToEmbed,\n      {\n        onload: createTagCallBack(\n          eventNames.TAG_LOADED,\n          tag.name,\n          tag,\n          addLoadedTag,\n        ),\n        onerror: createTagCallBack(\n          eventNames.TAG_LOAD_ERROR,\n          tag.name,\n          tag,\n          addLoadErrorTag,\n        ),\n      },\n      embedLocation,\n      tag.position === Position.BODY_START,\n    );\n\n    siteEmbed.embeddedNodes = embeddedNodes;\n  });\n}\n\n/**\n *\n * @param renderingInput - an Array of DOM Nodes to render\n * @param callbacks - { onloaded, onerror } - methods to notify when load has been completed for all nodes or failed for some\n * @param parentNode - the node to embed in\n * @param before - if to embed in the beginning of the body\n */\nfunction createSiteEmbed(\n  renderingInput: NodeToRender[],\n  callbacks: {\n    onload?: Function;\n    onerror?: Function;\n  },\n  parentNode: HTMLElement,\n  before: boolean,\n) {\n  const resultNodes: any = [];\n  let counters = 0,\n    errorState = false;\n\n  const onload = () => {\n    counters = counters - 1;\n    if (counters >= 0) {\n      runCallback(callbacks.onload, {});\n    }\n  };\n  const onerror = () => {\n    counters = counters - 1;\n    errorState = true;\n    if (counters >= 0) {\n      runCallback(callbacks.onerror, {error: true});\n    }\n  };\n  const firstChild = parentNode.firstChild; // captured so all nodes are inserted before it\n  renderingInput.forEach((node: NodeToRender) => {\n    if (node.tag === 'SCRIPT') {\n      counters = counters + 1;\n    }\n    const resultNode = buildNode(node, {onload, onerror});\n    resultNodes.push(resultNode);\n    if (before) {\n      parentNode.insertBefore(resultNode, firstChild);\n    } else {\n      parentNode.appendChild(resultNode);\n    }\n  });\n  if (counters === 0) {\n    runCallback(callbacks.onload, {}, true);\n  }\n  return resultNodes;\n}\n\n\nexport {applySiteEmbeds};\n","export function isExperimentOpen(experiments: Record<string, string>, spec: string): boolean {\n  return experiments && experiments[spec] === 'true';\n}\n","import {PageInfo, SiteEmbededTag, SiteTag} from \"../types\";\n\n/** render embed on all pages in case there in no page id*/\nconst isEmptyPageID = (p: PageInfo) => !p.id\n\n/** render embed tag on all page in case there is no pages */\nconst shouldRenderOnAllPages = (t: SiteEmbededTag) => !t.tag?.pages?.length;\n\n/** render embed in cases page id includes in embed's pages*/\nconst shouldRenderOnPage = (t: SiteEmbededTag, p: PageInfo) => t.tag?.pages?.includes(p.id || '') || false;\n\n/**\n * @return true if the tag should render on a given page, false otherwise\n * @param tag - the actual tag to check if should be filtered\n * @param pageInfo - page's information\n */\nexport function isTagValidForPage(tag: SiteEmbededTag, pageInfo: PageInfo): boolean {\n  return isEmptyPageID(pageInfo) ||\n    shouldRenderOnAllPages(tag) ||\n    shouldRenderOnPage(tag, pageInfo);\n}\n\nexport function filterTagsByPageID(tags: SiteEmbededTag[], pageInfo: PageInfo): SiteEmbededTag[] {\n  return tags.filter(tag => isTagValidForPage(tag, pageInfo));\n}\n\nexport function getSiteTagsFromSiteEmbed(siteEmbeds: SiteEmbededTag[]): SiteTag[] {\n  return siteEmbeds.map(s => s.tag);\n}\n","import {xhrGeneric} from '../utils/xhr';\nimport {SITES_API, METASITE_APP_DEF_ID, WIX_DOMAINS, SHOULD_RENDER_TAGS_PER_PAGE_SPEC} from '../consts/consts';\nimport {error} from '../utils/logger';\nimport {runCallback} from '../utils/callbackUtils';\nimport {extractQueryParameter} from '../utils/extractQueryParameter';\nimport {getCurrentPageInfo} from '../utils/wixEmbedsAPIClient';\nimport {getSiteTagParams, PageInfo, SiteEmbedsHandlerOptions} from '../types';\nimport {siteEmbedsHandler} from './siteApiHandlers';\n\nfunction buildTagApiUrl(baseUrl: string, metasiteId: string, wixSite?: boolean) {\n  return `${\n    baseUrl && !isWixSite(!!wixSite) ? baseUrl : ''\n  }/${SITES_API}${metasiteId}`;\n}\n\n// This is for template workarounds, they are on a Wix.com domain but their document type is \"template\"\nfunction isWixSite(wixSite: boolean): boolean {\n  let isWixDomain = false;\n  WIX_DOMAINS.forEach((domain) => {\n    if (!isWixDomain) {\n      isWixDomain = location.hostname.indexOf(domain) > 0;\n    }\n  });\n  return isWixDomain || wixSite;\n}\n\nfunction getSiteTags(params: getSiteTagParams) {\n  const {\n    metasiteId,\n    htmlsiteId,\n    baseUrl,\n    wixSite,\n    language,\n    categories,\n  } = params;\n\n  const uri = buildTagApiUrl(baseUrl, metasiteId, wixSite);\n\n  const headers = !wixSite && window.consentPolicyManager ? window.consentPolicyManager._getConsentPolicyHeader() : {};\n  const pageInfo: PageInfo = getCurrentPageInfo(window);\n\n  //This is to support removing tags by query parameter when the experiment is on: specs.cookieConsent.CcpWixSitesPixelTests\n  const omit: string | undefined = extractQueryParameter('omit');\n\n  const getAppToken = window.wixEmbedsAPI.getAppToken;\n  if (getAppToken) {\n    headers.authorization = runCallback(getAppToken, METASITE_APP_DEF_ID);\n  }\n\n  xhrGeneric(\n    uri,\n    (response: string) => {\n      // in wix-sites, we may only know the policy after tag manager server\n      // returns from the first call. so we should rerun init in this case\n      const initConsentPolicyManager = !categories && !!wixSite;\n      const siteEmbedsHandlerOptions: SiteEmbedsHandlerOptions = {\n        initConsentPolicyManager,\n        currentPageID: pageInfo.id,\n      };\n      siteEmbedsHandler(response, siteEmbedsHandlerOptions);\n    },\n    (err: any) => {\n      error(`Error loading site tags at ${uri}`);\n      error(err.message);\n    },\n    {\n      query: {wixSite: !!wixSite, htmlsiteId, language, categories, omit},\n      headers,\n    },\n  );\n}\n\nexport {getSiteTags};\n","import {PageInfo} from \"../types\";\n\nexport function getCurrentPageInfo(window: any) : PageInfo {\n  return (window.wixEmbedsAPI.getCurrentPageInfo &&\n    typeof window.wixEmbedsAPI.getCurrentPageInfo === 'function' &&\n    window.wixEmbedsAPI.getCurrentPageInfo()) || {};\n}\n","export function extractQueryParameter(parameterName: string, source = location.search) {\n  let queryParamData: string | undefined = (source.split(`${parameterName}=`)[1]);\n  queryParamData = queryParamData ? decodeURIComponent(queryParamData.split('&')[0]) : undefined;\n  return queryParamData;\n}\n","import {SiteTagsResponse, SiteEmbededTag, PageInfo, SiteEmbedsHandlerOptions} from '../types';\nimport {tryParse} from '../utils/tryParse';\nimport {setConfig, addTagEmbeds, updateConsentCategories, getSiteEmbedTags} from '../modules/stateCache';\nimport {error} from '../utils/logger';\nimport {applySiteEmbeds} from '../modules/siteEmbedder';\n\nexport function siteEmbedsHandler(response: string, siteEmbedsHandlerOptions: SiteEmbedsHandlerOptions) {\n  const embedsData: SiteTagsResponse = tryParse(response);\n  const {currentPageID, initConsentPolicyManager = false} = siteEmbedsHandlerOptions;\n  if (embedsData.errors && embedsData.errors.length > 0) {\n    error(JSON.stringify(embedsData.errors));\n  }\n  if (embedsData.config) {\n    updateConsentCategories(embedsData.config.consentPolicy);\n    if (initConsentPolicyManager && window.consentPolicyManager) {\n      window.consentPolicyManager.init({\n        consentPolicy: embedsData.config.consentPolicy,\n      });\n    }\n    setConfig(embedsData.config);\n  }\n  if (embedsData.tags) {\n    addTagEmbeds(embedsData.tags);\n    const pageInfo: PageInfo = {\n        id: currentPageID\n    };\n    const tags: SiteEmbededTag[] = getSiteEmbedTags();\n    applySiteEmbeds(tags, pageInfo, embedsData.config.experiments);\n  }\n}\n","import {SiteEmbededTag, Category, PageInfo} from '../types';\nimport { runCallback } from '../utils/callbackUtils';\nimport { applySiteEmbeds } from '../modules/siteEmbedder';\nimport {getSiteEmbedTags, calculateNewCategories, getConfig,} from '../modules/stateCache';\nimport { getSiteTags } from '../API/siteApi';\n\nexport function onPageNavigation(pageInfo: PageInfo) {\n  removeReloadableEmbeds();\n  const tags: SiteEmbededTag[] = getSiteEmbedTags();\n  const config = getConfig()\n  applySiteEmbeds(tags, pageInfo, config.experiments);\n}\n\nexport function onConsentPolicyChanged(event: any) {\n  if (event && event.detail && event.detail.policy) {\n    const categories: Category[] = calculateNewCategories(event.detail.policy);\n    if (categories.length) {\n      getSiteTags({\n        baseUrl: window.wixEmbedsAPI.getExternalBaseUrl(),\n        htmlsiteId: window.wixEmbedsAPI.getHtmlSiteId(),\n        metasiteId: window.wixEmbedsAPI.getMetaSiteId(),\n        wixSite: window.wixEmbedsAPI.isWixSite(),\n        language: window.wixEmbedsAPI.getLanguage(),\n        categories,\n      });\n    }\n  }\n}\n\nfunction removeReloadableEmbeds() {\n  const tagsToRemove = getSiteEmbedTags();\n  tagsToRemove.forEach((siteEmbed: SiteEmbededTag) => {\n    if (!siteEmbed.tag.loadOnce) {\n      siteEmbed.embeddedNodes && siteEmbed.embeddedNodes.forEach((node: any) => {\n        runCallback(() => {\n          node.parentNode.removeChild(node);\n        });\n      });\n      // Clear any memory reference to prevent leaky leakies having fun in memory\n      siteEmbed.embeddedNodes = null;\n    }\n  });\n}\n","import { getLoadErrorTags, getLoadedTags, getLoadingTags, getConfig } from './modules/stateCache';\nimport { publishEvent, eventNames } from './modules/events';\nimport { onPageNavigation, onConsentPolicyChanged } from './integration/viewer';\nimport { getSiteTags } from './API/siteApi';\n\nexport const api = {\n  getLoadedTags,\n  getLoadingTags,\n  getLoadErrorTags,\n  getConfig,\n};\n\nlet initTagManager = () => {\n  const wixEmbedsAPI = (window as any).wixEmbedsAPI;\n  getSiteTags({\n    baseUrl: wixEmbedsAPI.getExternalBaseUrl(),\n    htmlsiteId: wixEmbedsAPI.getHtmlSiteId(),\n    metasiteId: wixEmbedsAPI.getMetaSiteId(),\n    language: wixEmbedsAPI.getLanguage(),\n    wixSite: wixEmbedsAPI.isWixSite(),\n  });\n  (window as any).wixEmbedsAPI.registerToEvent(\n    'pageNavigation',\n    onPageNavigation,\n  );\n  document.addEventListener('consentPolicyChanged', onConsentPolicyChanged);\n  registerTagManagerAPI();\n};\n\nregisterToWixEmbedsAPI();\n\nfunction registerTagManagerAPI() {\n  window.wixTagManager = api;\n  publishEvent(eventNames.TAG_MANAGER_LOADED, window as any, api);\n}\n\nfunction registerToWixEmbedsAPI() {\n  if (\n    (window as any).wixEmbedsAPI &&\n    typeof (window as any).wixEmbedsAPI.registerToEvent === 'function'\n  ) {\n    initTagManager();\n  } else {\n    (window as any).addEventListener(\n      'wixEmbedsAPIReady',\n      () => {\n        initTagManager();\n        // Noop-ified to prevent duplicate callbacks\n        initTagManager = function () {};\n      },\n      false,\n    );\n  }\n}\n"],"sourceRoot":""}